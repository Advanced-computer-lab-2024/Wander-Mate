<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>View Products | Wander-Mate</title>
    <link rel="stylesheet" href="../styles/register.css" />
    <style>
      /* Star rating styles */
      .star-rating span {
        font-size: 1.5em;
        color: black; /* Initial color (white) */
        cursor: pointer;
        transition: color 0.3s;
        padding: 5px;
        margin-right: 2px;
      }

      /* Hover effect starting from the left */
      .star-rating span:hover,
      .star-rating span:hover ~ span {
        color: rgb(0, 0, 0);
      }

      .star-rating span:hover,
      .star-rating span:hover ~ span {
        color: gold;
      }

      /* Selected stars should remain yellow */
      .star-rating .selected {
        color: gold;
      }

      .rating-message {
        color: green;
        font-size: 0.9em;
        margin-left: 10px;
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <div class="title">Available Products</div>

      <div class="search-section">
        <label for="productName">Search by Product Name:</label>
        <input type="text" id="productName" placeholder="Enter product name" />
      </div>

      <div class="filter-section">
        <label for="minPrice">Min Price:</label>
        <input type="number" id="minPrice" placeholder="0" />
        <label for="maxPrice">Max Price:</label>
        <input type="number" id="maxPrice" placeholder="1000" />
        <button id="applyFiltersButton">Apply Filters</button>
        <button id="resetButton">Reset</button>
        <button id="sortButton">Sort by Ratings</button>
      </div>

      <div class="product-list" id="productList">
        <!-- Products will be dynamically inserted here -->
      </div>
    </div>

    <script>
      let allProducts = [];
      let allSellers = [];
      let sellerMap = {};

      async function fetchSellers() {
        try {
          const response = await fetch("http://localhost:8000/getSellers");
          if (response.ok) {
            const data = await response.json();
            allSellers = data.sellers;
            sellerMap = allSellers.reduce((map, seller) => {
              map[seller._id] = seller.Username;
              return map;
            }, {});
          } else {
            console.error("Failed to fetch sellers:", response.statusText);
          }
        } catch (error) {
          console.error("Error fetching sellers:", error);
        }
      }

      async function fetchProducts() {
        try {
          const response = await fetch(
            "http://localhost:8000/viewSellerProducts"
          );
          const products = await response.json();

          if (response.ok) {
            allProducts = products;
            applyFilters(); // Apply initial filters to show all products
          } else {
            document.getElementById("productList").innerHTML =
              "<p>No products available</p>";
          }
        } catch (error) {
          console.error("Error fetching products:", error);
          document.getElementById("productList").innerHTML =
            "<p>An error occurred while fetching products.</p>";
        }
      }

      function displayProducts(products) {
        const productList = document.getElementById("productList");
        productList.innerHTML = ""; 

        products.forEach((product) => {
          const productItem = document.createElement("div");
          productItem.className = "product-item";

          const productImage = `http://localhost:8000/products/${product._id}/image`;

          productItem.innerHTML = `
            <img src="${productImage}" alt="Product Image" class="product-image">
            <div class="product-details">
              <h2 class="product-name">${product.name}</h2>
              <p class="product-description">${product.description}</p>
              <p class="product-price">Price: $${product.price.toFixed(2)}</p>
              <p class="product-seller">Seller: ${sellerMap[product.seller] || "Unknown"}</p>
              <p class="product-ratings">Ratings: ${product.ratings ? product.ratings.toFixed(2) : 'No ratings yet'}</p>

              <!-- Star Rating Section -->
              <div class="star-rating" id="rating-${product._id}">
                ${[1, 2, 3, 4, 5]
                  .map((star) => `<span onclick="rateProduct('${product._id}', ${star})">&#9733;</span>`)
                  .join("")}
                <span id="rating-message-${product._id}" class="rating-message"></span>
              </div>

              <!-- Review Section -->
              <div class="review-section">
                <input type="text" class="review-input" id="review-${product._id}" placeholder="Add a review">
                <button onclick="submitReview('${product._id}')">Submit Review</button>
              </div>
              <p class="product-reviews">Reviews: 
                  <ul id="reviews-list-${product._id}">
                    <!-- Reviews will be dynamically loaded here -->
                  </ul>
              </p>
            </div>
          `;

          productList.appendChild(productItem);

          // Fetch and display reviews for each product
          fetchProductReviews(product._id);
        });
      }

      async function rateProduct(productId, rating) {
        const userId = sessionStorage.getItem("userId"); // Retrieve user ID from session storage
        if (!userId) {
          alert("You must be logged in to rate a product.");
          return;
        }

        try {
          const response = await fetch("http://localhost:8000/rateProduct", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ userId, productId, rating }),
          });

          const data = await response.json();

          if (response.ok) {
            document.getElementById(`rating-message-${productId}`).textContent = "Thank you for your rating!";
            setStarRating(productId, rating); // Set the star colors based on rating
            await updateProductRatingsDisplay(productId); // Fetch and display updated ratings
          } else {
            alert(data.message || "Failed to post rating.");
          }
        } catch (error) {
          console.error("Error posting rating:", error);
          alert("An error occurred while posting the rating.");
        }
      }

      // Helper function to apply the "selected" class to stars up to the rating given
      function setStarRating(productId, rating) {
        const stars = document.querySelectorAll(`#rating-${productId} span`);
        stars.forEach((star, index) => {
          if (index < rating) {
            star.classList.add("selected");
          } else {
            star.classList.remove("selected");
          }
        });
      }

      async function updateProductRatingsDisplay(productId) {
        try {
          const response = await fetch(`http://localhost:8000/viewProduct/${productId}`);
          const product = await response.json();

          if (response.ok) {
            // Update the rating display in the UI
            const productElement = document.getElementById(`rating-${productId}`);
            if (productElement) {
              productElement.previousElementSibling.textContent = `Ratings: ${product.ratings ? product.ratings.toFixed(2) : 'No ratings yet'}`;
            }
          } else {
            console.error("Failed to fetch updated product rating:", response.statusText);
          }
        } catch (error) {
          console.error("Error fetching updated product rating:", error);
        }
      }

      async function submitReview(productId) {
        const reviewText = document.getElementById(`review-${productId}`).value;
        const userId = sessionStorage.getItem("userId"); // Retrieve user ID from session storage

        if (!userId || !reviewText) {
          alert("You must be logged in and enter a review to submit.");
          return;
        }

        try {
          const response = await fetch("http://localhost:8000/reviewProduct", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              productId,
              userId,
              review: reviewText,
            }),
          });
          const data = await response.json();

          if (response.ok) {
            alert(data.message);
            document.getElementById(`review-${productId}`).value = ""; // Clear input after submitting
            await fetchProductReviews(productId); // Fetch and display updated reviews
          } else {
            alert("Failed to post review.");
          }
        } catch (error) {
          console.error("Error posting review:", error);
          alert("An error occurred while posting the review.");
        }
      }

      async function fetchProductReviews(productId) {
        try {
          const response = await fetch(`http://localhost:8000/getProductReviews/${productId}`);
          const data = await response.json();

          if (response.ok) {
            // Update the reviews section with the fetched reviews
            const reviewsList = document.getElementById(`reviews-list-${productId}`);
            if (reviewsList) {
              reviewsList.innerHTML = data.reviews
                .map((review) => `<li>${review}</li>`)
                .join("");
            }
          } else {
            console.error("Failed to fetch reviews:", response.statusText);
          }
        } catch (error) {
          console.error("Error fetching reviews:", error);
        }
      }

      // Apply filters
      function applyFilters() {
        const productName = document.getElementById("productName").value.toLowerCase();
        const minPrice = parseFloat(document.getElementById("minPrice").value) || 0;
        const maxPrice = parseFloat(document.getElementById("maxPrice").value) || Infinity;

        const filteredProducts = allProducts.filter((product) => {
          return (
            product.name.toLowerCase().includes(productName) &&
            product.price >= minPrice &&
            product.price <= maxPrice
          );
        });

        displayProducts(filteredProducts);
      }

      // Reset filters
      function resetFilters() {
        document.getElementById("productName").value = "";
        document.getElementById("minPrice").value = "";
        document.getElementById("maxPrice").value = "";
        displayProducts(allProducts); // Reset to show all products
      }

      // Sort products by ratings
      function sortProductsByRatings() {
        const sortedProducts = [...allProducts].sort((a, b) => b.ratings - a.ratings);
        displayProducts(sortedProducts);
      }

      document.addEventListener("DOMContentLoaded", () => {
        fetchSellers(); // Fetch all sellers
        fetchProducts(); // Fetch all products

        document.getElementById("applyFiltersButton").addEventListener("click", applyFilters);
        document.getElementById("resetButton").addEventListener("click", resetFilters);
        document.getElementById("sortButton").addEventListener("click", sortProductsByRatings);
      });
    </script>
  </body>
</html>
